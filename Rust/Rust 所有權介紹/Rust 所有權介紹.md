# Rust 所有權介紹
### 前言
在記憶體管理這部分，與平常較常看到的語言如 C/C++、C#、Java 等語言針對記憶體的處理方式 Rust 有不同的作法。

先來看其他語言對記憶體的處裡方式，首先是 C/C++，當需要使用到記憶體的時候，需要先跟系統要一塊記憶體空間，當不再使用的時候，要自己手動釋放，這是第一種方式。

在 C# 與 Java 對於記憶體處理方式，採用的是 Garbage Collection 的方式，他會識別沒有在使用的物件，然後自動去釋放記憶體，使用者無需手動釋放，這是第二種方式。

第三種方式也就是 Rust 所使用的方式**所有權**，他會在變數離開作用域的時候，自動去釋放記憶體，但是，有一些規則是需要去了解的。

### 所有權的規則
- Rust 裡的每一個數值都有擁有者 (Owner)
- 同一個時間內只能有一個擁有者
- 當擁有者離開作用域的時候，數值就會被丟棄 (Drop)

### 純量型別與複合型別
純量型別有：整數、浮點數、布林與字元 (放在堆疊 Stack)

複合型別有：元組、陣列 (放在堆積 Heap)

為甚麼要針對這兩種型別做介紹呢?

因為這兩類型別在記憶體的處裡上有些不一樣，簡單來說就是放在  Heap 上面的記憶體對於所有權會比較需要注意。

以純量型別來說，他們都是放在堆積上面，所以再將一個純量的變數指定到另外一個純量型別時，裡面的值會直接拷貝一份 (copy)，所以所有權並沒有改變，程式碼如下所示：

```rs
let a = 6;
let b = a;

println1!("a = {a}, b = {b}", a, b);  // a = 6, b = 6
```

但如果是非純量型別這種指派方式就不一樣了，以 String 類型來說

```rs
let s1 = String::from("hi");
let s2 = s1;
```

這個 String 會放在 Heap 上面，當 s2 賦值為 s1 的時候，s1 會自動失效，此時就是發生了移動 (Move)，所有權發生轉移了。

此時，s1 後續就無法再繼續使用，然後當離開作用域的時候，只需要去將 s2 進行記憶體釋放的動作 (Drop)。

簡單說明一下上面的原理，在一開始 s1 那段程式碼建立的時候，在 Stack 上面會放置 s1 的變數，變數內容為一個指標，這個指標用來指向真正 hi 那串文字的記憶體位置，也就是在 Heap 上面的位置。 (到這一部分與大部分程式碼是相同的概念)

當將 s2 賦值為 s1 的時候，發生了所有權的移動，此時，s1 就不再擁有這塊記憶體的所有權，也就是 s1 沒有在指向 hi 那個字串的記憶體了，所以最後當離開作用域的時候，就是靠 s2 這個當前的擁有者去將記憶體進行釋放 。